import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.WebSocket;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class GitLabDuoGraphQL {

    // --- CONFIGURATION ---
    private static final String GITLAB_HOST = "gitlab.com"; 
    private static final String TOKEN = "YOUR_PERSONAL_ACCESS_TOKEN"; // Must have 'api' scope
    
    // Global ID of the resource (User, Project, or Issue) you are chatting "in context of".
    // Using your User ID is the safest default context.
    private static final String RESOURCE_ID = "gid://gitlab/User/YOUR_USER_ID_HERE"; 
    
    // Unique ID generated by the client to link the Question (Mutation) to the Answer (Subscription)
    private static final String CLIENT_SUB_ID = UUID.randomUUID().toString();

    public static void main(String[] args) throws Exception {
        System.out.println("--- Starting GitLab Duo Chat (GraphQL) ---");
        
        CountDownLatch latch = new CountDownLatch(1); // Keep app alive for the async response

        // 1. Open WebSocket Connection (ActionCable Protocol)
        // GitLab uses the "ActionCable" protocol over WebSockets.
        WebSocket.Builder wsBuilder = HttpClient.newHttpClient().newWebSocketBuilder();
        wsBuilder.header("Sec-WebSocket-Protocol", "graphql-transport-ws");
        wsBuilder.header("Authorization", "Bearer " + TOKEN);

        URI wsUri = URI.create("wss://" + GITLAB_HOST + "/-/cable");
        
        wsBuilder.buildAsync(wsUri, new DuoWebSocketListener(latch)).join();
        
        // Wait for conversation to finish
        latch.await(30, TimeUnit.SECONDS); 
    }

    // --- WEBSOCKET LISTENER ---
    private static class DuoWebSocketListener implements WebSocket.Listener {
        private final CountDownLatch latch;
        private StringBuilder buffer = new StringBuilder();

        public DuoWebSocketListener(CountDownLatch latch) {
            this.latch = latch;
        }

        @Override
        public void onOpen(WebSocket webSocket) {
            System.out.println("1. WebSocket Connected. Subscribing...");
            
            // 2. Subscribe to aiCompletionResponse
            // We match the subscription to our specific CLIENT_SUB_ID and RESOURCE_ID.
            String subscriptionQuery = 
                "subscription aiCompletionResponse($clientSubscriptionId: String!, $resourceId: AiModelID!) { " +
                "  aiCompletionResponse(clientSubscriptionId: $clientSubscriptionId, resourceId: $resourceId) { " +
                "    content " + // The chunk of text from the AI
                "    errors " +
                "  } " +
                "}";

            // ActionCable requires a specific JSON structure for the "identifier"
            String identifier = String.format(
                "{\"channel\":\"GraphqlChannel\",\"query\":\"%s\",\"variables\":{\"clientSubscriptionId\":\"%s\",\"resourceId\":\"%s\"}}",
                escapeJson(subscriptionQuery), CLIENT_SUB_ID, RESOURCE_ID
            );

            String subscribeCmd = String.format(
                "{\"command\":\"subscribe\",\"identifier\":\"%s\"}", 
                escapeJson(identifier)
            );

            webSocket.sendText(subscribeCmd, true);
        }

        @Override
        public java.util.concurrent.CompletionStage<?> onText(WebSocket webSocket, CharSequence data, boolean last) {
            buffer.append(data);
            if (last) {
                String message = buffer.toString();
                buffer.setLength(0);
                handleMessage(webSocket, message);
            }
            return WebSocket.Listener.super.onText(webSocket, data, last);
        }

        private void handleMessage(WebSocket webSocket, String msg) {
            // ActionCable Pings (keep-alive)
            if (msg.contains("\"type\":\"ping\"")) return;
            if (msg.contains("\"type\":\"welcome\"")) return;
            
            // Subscription Confirmation
            if (msg.contains("\"type\":\"confirm_subscription\"")) {
                System.out.println("2. Subscription Confirmed. Sending Prompt...");
                triggerChatMutation();
                return;
            }

            // Data Payload (The AI Response)
            if (msg.contains("\"content\":")) {
                String content = extractContent(msg);
                if (content != null) {
                    System.out.print(content); // Stream to console
                }
            }
        }
    }

    // --- HTTP MUTATION SENDER ---
    private static void triggerChatMutation() {
        try {
            // 3. Send the Mutation to trigger the AI
            // We pass the SAME clientSubscriptionId here so the backend knows where to send the answer.
            String mutation = 
                "mutation chat($input: AiActionInput!) { " +
                "  aiAction(input: $input) { " +
                "    errors " +
                "  } " +
                "}";

            String variables = String.format(
                "{" +
                "  \"input\": {" +
                "    \"chat\": {" +
                "      \"resourceId\": \"%s\"," +
                "      \"content\": \"How do I use Java Streams API?\"" +
                "    }," +
                "    \"clientSubscriptionId\": \"%s\"" +
                "  }" +
                "}", RESOURCE_ID, CLIENT_SUB_ID);

            String requestBody = String.format(
                "{\"query\": \"%s\", \"variables\": %s}", 
                escapeJson(mutation), variables
            );

            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://" + GITLAB_HOST + "/api/graphql"))
                .header("Authorization", "Bearer " + TOKEN)
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                .build();

            HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("3. Prompt Sent. Waiting for stream...");
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Helper: Escape string for JSON
    private static String escapeJson(String input) {
        return input.replace("\"", "\\\"").replace("\n", "\\n");
    }

    // Helper: Extract "content" field from JSON response (Quick regex for demo purposes)
    private static String extractContent(String json) {
        // Matches "content":"..." 
        java.util.regex.Pattern p = java.util.regex.Pattern.compile("\"content\":\"(.*?)\"");
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {
            return m.group(1).replace("\\n", "\n").replace("\\\"", "\"");
        }
        return null;
    }
}
